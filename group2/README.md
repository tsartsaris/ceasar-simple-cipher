Σε αυτό το πρόβλημα θέλουμε να δείξουμε οτι με τη μέθοδο του διακριτού λογάριθμου, αν κατά την αποθήκευση των κωδικών απιλέξουμε μεγάλο p πρώτο, είναι δύσκολο για έναν επιτιθέμενο να βρεί τον κωδικό πρόσβασης αν έχει πρόσβαση στη βάση με τους κρυπτογραφημένους κωδικούς. 
<ul>
<li>Όλο το implementation θα γίνει με python.</li>
<li>Όλα τα τεστς έγιναν με έναν AMD Athlon Black edition 4-core at 2.7 Gs with 8Gs of RAM</li>
<li>Η μη πρωτόγονη μέθοδος υπολογισμού θα είναι η Baby step - Giant STEP (το αρχείο <a href="https://github.com/tsartsaris/ceasar-simple-cipher/blob/master/group2/baby_step_giant_step.py" target="_blank">Python</a> έχει τη μέθοδο αυτή)</li>
<li>Οι πρώτοι αριθμοί θα επιλεχθούν από την δεξιά στήλη των πρωτων 100000 πρώτων αριθμών από τη σελίδα
<a href="http://primes.utm.edu/lists/small/100000.txt" target="_blank">Primes</a></li>
<li>Η πράξη κρυπτογράφησης θα είναι της μορφής 2**(x)modp</li>
</ul>
Ο κωδικός που θα χρησιμοποιήσουμε θα είναι ο "3469". Επιλέγουμε σαν πρώτο αριθμό το "12437" οπότε το κρυπρογραφημένο password θα είναι το "87". 
Έστω τώρα ότι ο επιτιθέμενος γνωρίζει ότι το κρυπτογραφημένο password είναι το "87" και ότι κάνουμε χρήση του πρώτου "12437". Με τη μέθοδο baby step-Giant step προσπαθεί να υπολογίσει το αρχικό password και βλέπει ότι πέρνει απάντηση 
<p>
So        log_2 87	(mod 12437) =	3469 
or equiv.     2^3469	(mod 12437) =	87 <br>
0.000437021255493 ms</p>
Ας αυξήσουμε τον πρώτο αριθμό σε 628427 οπότε το κρυπτογραφημένο password θα είναι 92436. Έστω ότι ο επιτιθέμενος ξέρει ότι το κρυπτογραφημένο password είναι το 92436 και ο πρώτος έιναι το 628427. Έχει απάντηση 
<p>
So        log_2 92436	(mod 628427) =	3469 
or equiv.     2^3469	(mod 628427) =	92436<br> 
0.00910592079163 ms</p>
Ο χρόνος είναι καλύτερος από πριν σε σχέση δυσκολίας αλλά ακοα είμαστε μακριά από το αποτέλεσμα που επιθυμούμε. 
Αυξάνουμε τον πωτο σε 1299827 και το αποτέλεσμα που έχουμε θα είναι 1174364. Ο επιτιθέμενος πάλει βρίσκει λύση 
<p>
So        log_2 1174364	(mod 1299827) =	3469 
or equiv.     2^3469	(mod 1299827) =	1174364 <br>
0.020919084549 ms</p>
Κάτι κάνουμε σε χρόνους. Ας πάμε λίγο παρακάτω με τον πρώτο που επιλέγουμε να έχουμε 8ψήφιο, "13111229", οπότε τώρα ο επιτιθέμενος έχει κρυπτογραφημένο το 12112061 και βρίσκει απάντηση 
<p>
So        log_2 12112061	(mod 13111229) =	3469 
or equiv.     2^3469	(mod 13111229) =	12112061 <br>
0.637586116791 ms </p>
Επίλεγουμε 9ψήφιο πρώτο έστω το "103588109" και το κρυπτογραφημένο password είναι "85845298" . Ο επιτιθέμενος με την ίδια μέθοδο προσπαθεί και πάλι να βρει το αρχικό password και το καταφέρνει έχοντας απάντηση 
<p>
So        log_2 85845298	(mod 103588109) =	3469 
or equiv.     2^3469	(mod 103588109) =	85845298 <br>
21.6247158051 seconds.</p> 
Παρατηρούμε ότι με 9ψήφιο πρώτο ο χρόνος εκτοξέυθηκε. Κάνουμε μία προσπάθεια με 10ψήφιο να δούμε αν έχουμε λύση. 


