Σε αυτό το πρόβλημα θέλουμε να δείξουμε οτι με τη μέθοδο του διακριτού λογάριθμου, αν κατά την αποθήκευση των κωδικών απιλέξουμε μεγάλο p πρώτο, είναι δύσκολο για έναν επιτιθέμενο να βρεί τον κωδικό πρόσβασης αν έχει πρόσβαση στη βάση με τους κρυπτογραφημένους κωδικούς. 
<ul>
<li>Όλο το implementation θα γίνει με python.</li>
<li>Όλα τα τεστς έγιναν με έναν AMD Athlon Black edition 4-core at 2.7 Gs with 8Gs of RAM</li>
<li>Η μη πρωτόγονη μέθοδος υπολογισμού θα είναι η Baby step - Giant STEP (το αρχείο <a href="https://github.com/tsartsaris/ceasar-simple-cipher/blob/master/group2/baby_step_giant_step.py" target="_blank">Python</a> έχει τη μέθοδο αυτή)</li>
<li>Οι πρώτοι αριθμοί θα επιλεχθούν από την δεξιά στήλη των πρωτων 100000 πρώτων αριθμών από τη σελίδα
<a href="http://primes.utm.edu/lists/small/100000.txt" target="_blank">Primes</a></li>
<li>Η πράξη κρυπτογράφησης θα είναι της μορφής 2**(x)modp</li>
</ul>
Ο κωδικός που θα χρησιμοποιήσουμε θα είναι ο "9". Επιλέγουμε σαν πρώτο αριθμό το "23" οπότε το κρυπρογραφημένο password θα είναι το "6". 
Έστω τώρα ότι ο επιτιθέμενος γνωρίζει ότι το κρυπτογραφημένο password είναι το "6" και ότι κάνουμε χρήση του πρώτου "23". Με τη μέθοδο baby step-Giant step προσπαθεί να υπολογίσει το αρχικό password και βλέπει ότι πέρνει απάντηση 
2^9	(mod 23) =	6 μέσα σε 8.20159912109e-05 ms
Ας αυξήσουμε τον πρώτο αριθμό σε 3739 οπότε το κρυπτογραφημένο password θα είναι 512. Έστω ότι ο επιτιθέμενος ξέρει ότι το κρυπτογραφημένο password είναι το 512 και ο πρώτος έιναι το 3739. Έχει απάντηση 2^2679	(mod 3739) =	512 
σε 0.000205039978027 ms. Ο χρόνος είναι καλύτερος από πριν σε σχέση δυσκολίας αλλά ακοα είμαστε μακριά από το αποτέλεσμα που επιθυμούμε. 
Αυξάνουμε τον πωτο σε 
